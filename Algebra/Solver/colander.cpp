// colander.cpp
// Copyright (C) 2001 by Joel A. Shapiro -- All Rights Reserved

//	solve equations for problem in Andes2,
//	from files generated by Collin, 1/29/01
//	Just as list2 but for new solver format
//#define LRDC_MAIN
#include "lrdcstd.h"

#define _H_STANDARD_H_
#define LZ_EXTERN_SPEC LRDC_EXTERN_SPEC
#define LZ_INIT_INT_SPEC LRDC_INIT_INT_SPEC
#define LZ_INIT_PTR_SPEC LRDC_INIT_PTR_SPEC
#define LZ_SAFE_DELETE LRDC_SAFE_DELETE
//#include "../src/dbg.h"
#include "../src/extstruct.h"

#include <fstream>

//#include "../src/decl.h"
string getaline(istream &instr);				// getaline
typedef int varindx;
void checkeqs( vector<binopexp *> * & , vector<varindx> * &, 	// checkeqs
	       ofstream &);

//////////////////////////////////////////////////////////////////////////////
// from here down is for DLL support
//////////////////////////////////////////////////////////////////////////////
#include <iomanip>

//////////////////////////////////////////////////////////////////////////////
// prototypes for externally defined routines (should be .h'ed
bool handleInput(string& aLine);

//////////////////////////////////////////////////////////////////////////////
// static/local error messages reurned for copying
static char* error[] = {
	"Unable to read source file",
	"Unable to write destination file",
	"Unexpected Input",
	"So far so good",
	"nil",
};
char lzbfr[4096]; // major kludge but this needs to be rewritten once it's in working anyway
std::ifstream inFile;

#include "../src/unitabr.h"
void constsfill();
extern unitabrs unittable;
bool getallfile(ifstream & infile );
void eqnumsimp(expr * &, const bool);
expr * dimenchk(const bool fix, expr * & ex);
//////////////////////////////////////////////////////////////////////////////
// opens src reads it and usees contents to determine contents of dst file
char* doColAnderMain(const char* const src, const char* const dst) {
 	char* result = error[0];
	
	LRDC_SAFE_DELETE(canoneqf);
	canoneqf = new vector<binopexp*>; // ugly globals
  LRDC_SAFE_DELETE(canonvars);
	canonvars = new vector<physvar*>;
	unittable.fill();
	constsfill();

	ifstream inFile1(src, ios::in | ios::binary);
	if (inFile) {
		bool isOkay = true;
		if (! getallfile(inFile1))
			throw(string("couldn't finish reading input"));
		//while (! inFile.eof()) {
		//	string aLine = getaline(inFile);
		//	if (! handleInput(aLine)) {
		//		isOkay = false;
		//		result = error[2];
		//		break;
		//	}
		//}
		inFile1.close();
		if (isOkay) {
			ofstream outFile(dst, ios::out);
			if (outFile) {
		    vector<varindx>* vars = new vector<varindx>;
				expr* eqexpr;
				expr* dimtroub;
			  for (int k=0; k<canonvars->size(); k++) {
					eqexpr = (expr*)(*canoneqf)[k];
					eqnumsimp(eqexpr, true);
					dimtroub = dimenchk(true, eqexpr);
					if (dimtroub != (expr*)NULL) {
						dimtroub->dbgprint(4);
						throw string("dimensional inconsistency in input equation");
					}
					if (eqexpr->etype != binop) {
						throw string("dimenchk made nonbinop equation");
					}
					(*canoneqf)[k] = (binopexp*)eqexpr;
				}
				{
					for (int k=0; k<canonvars->size(); k++) {
						if ((*canonvars)[k]->isused == true) {
							vars->push_back(k);
						}
					}
				}

				numpasses = 0;
				checkeqs(canoneqf, vars, outFile);
				if (canoneqf->size() > 0) {
					outFile << "<UNSVLEQS>" << endl;
					for (int k=0; k < canoneqf->size(); k++) {
			      outFile << (*canoneqf)[k]->getInfix() << endl;
					}
				}
				if (vars->size() > 0) {
				  outFile << "<UNSVLVARS>" << endl;
					for (int k=0; k < vars->size(); k++)  {
						try {
							outFile << "(" << (*canonvars)[(*vars)[k]]->clipsname << " NIL)" << endl;
						} catch (...) {
							throw string("Says we have variables undefined");
						}
					}
				}
				outFile.close();
			}
			result = error[3];
		} else {
			result = error[1];
		}
	}

	LRDC_SAFE_DELETE(canoneqf);
	LRDC_SAFE_DELETE(canonvars);

	return result;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
std::string getaline(std::istream& in);
#define TEMP_FILE "andes241.tlz"
char* solveTheProblem() {
	try {
		ofstream outFile(TEMP_FILE, ios::out);
		if (outFile) {
			vector<varindx>* vars = new vector<varindx>();
			expr* eqexpr;
			expr* dimtroub;
			try {
				for (int k=0; k<canoneqf->size(); k++) {
					eqexpr = (expr*)(*canoneqf)[k];
					eqnumsimp(eqexpr, true);
					dimtroub = dimenchk(true, eqexpr);
					if (dimtroub != (expr*)NULL) {
						throw string("dimensional inconsistency in input equation");
					}
					if (eqexpr->etype != binop) {
						throw string("dimenchk made nonbinop equation");
					}
					(*canoneqf)[k] = (binopexp*)eqexpr;
				}
				{ 
					for (int k=0; k<canonvars->size(); k++) {
						if ((*canonvars)[k]->isused) {
							vars->push_back(k);
						}
					}
				}
				numpasses = 0;
				checkeqs(canoneqf, vars, outFile);
			} catch (...) {
				throw string("checkeqs barfed");
			}
			try {
				if (canoneqf->size() > 0) {
					outFile << "<UNSLVEQS>" << endl;
					for (int k=0; k<canoneqf->size(); k++) {
			      outFile << (*canoneqf)[k]->getInfix() << endl;
					}
				}
			} catch (...) {
				throw string("failed on write unsolved equations");
			}
			try {
				if (vars->size() > 0) {
					outFile << "<UNSLVVARS>" << endl;
					for (int k=0; k<vars->size(); k++)  {
						outFile << "(" << (*canonvars)[(*vars)[k]]->clipsname << " nil)" << endl;
					}
				}
			} catch (...) {
				throw string("failed on write unsolved variables");
			}
			outFile.close();
		} else {
			throw string("unable to create solution buffer");
		}
	} catch (string message) {
		throw message;
	} catch (...) {
		throw string("solveTheProblem went boom!!");
	}
	try {
		inFile.open(TEMP_FILE, std::ios::in);// | std::ios::binary);
		inFile.clear(0);
		inFile.seekg(0);
		int tk;
		try {
			tk = inFile.eof();
		} catch (...) {
			throw string("eof?!?");
		}
		if (! tk) {
			string t;
			try {
				t = getaline(inFile);
			} catch (...) {
				throw string("getaline fails???");
			}
			try {
				sprintf(lzbfr, "%s", t.c_str());
			} catch(...) {
				throw string("copy is wrong??");
			}
			return lzbfr;
		} else {
			return error[4];
		}
	} catch (string message) {
		throw message;
	} catch (...) {
		throw string("Read went bad!!");
	}
	return error[3];
}

///////////////////////////////////////////////////////////////////////////////
char* solveMoreOfTheProblem() {
	try {
		if (! inFile.eof()) {
			string t = getaline(inFile);
			if (t.size() == 0) {
				inFile.clear();
				inFile.close();
				return error[4];
			} else {
				sprintf(lzbfr, "%s", t.c_str());
			}
			return lzbfr;
		} else {
			inFile.clear();
			inFile.close();
			return error[4];
		}
	} catch (string message) {
		inFile.clear();
		inFile.close();
		throw message;
	} catch (...) {
		inFile.clear();
		inFile.close();
		throw string("More went bad!!");
	}
	return error[3];
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////