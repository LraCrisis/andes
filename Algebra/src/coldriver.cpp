// coldriver.cpp
// Copyright (C) 2001 by Joel A. Shapiro -- All Rights Reserved

//	solve equations for problem in Andes2,
//	from files generated by Collin, 1/29/01
//	Just as list2 but for new solver format
// BvdS: I couldn't get this to work.  See test file ../test/str.cpp
#define USE_TEMP_FILE  0 // use crufty temp file to communicate with ourself
#define IAmMain
#include <stdio.h>
#include "extstruct.h"
#include "decl.h"
#include "unitabr.h"
#include "indyset.h"
#include "indysgg.h"
#include "dbg.h"
#if USE_TEMP_FILE 
#include <fstream>
#else
#include <iostream>
#include <sstream>
#endif
#include "justsolve.h"
// int dbgnum;
bool handleInput(std::string& aLine);
void doinitinit();
int checksol(const binopexp * const eqexpr, const vector<double> * const sols,
	     const double reltverr);
void dimchkeqf(ostream & outstr);

extern vector<valander *> *canongrads;

bool isFirst = true;		// instantiation moved here by Linn
//////////////////////////////////////////////////////////////////////////////
// static/local error messages reurned for copying
static char* error[] = {
	"Unable to read source file",
	"Unable to write destination file",
	"Unexpected Input",
	"So far so good",
	"nil",
};
char lzbfr[4096]; // major kludge but this needs to be rewritten once
// it's in working anyway
#if USE_TEMP_FILE
std::ifstream inFile;
#else
std::istringstream inFile;
#endif

void constsfill();
extern unitabrs unittable;

/************************************************************************
 * doColAnderMain(src,dest)						*
 *	reads equations in from the file named src, writes solution in	*
 *	file named dst							*
 * returns one of Error[]						*
 ************************************************************************/
char* doColAnderMain(const char* const src, const char* const dst) {
  int k;
  char* result = error[0];
  if (isFirst) doinitinit();
  ifstream inFile1(src, ios::in | ios::binary);
  if (inFile) {
    bool isOkay = true;
    if (! getallfile(inFile1))
      throw(string("couldn't finish reading input"));
    inFile1.close();
    indyDoneAddVar();
    if (isOkay) {
      ofstream outFile(dst, ios::out);
      if (outFile) {
	numsols->assign(canonvars->size(),HUGE_VAL);
	if (solveeqs(outFile)) {
	  // should we do checking of solution here?
	  bool discrep = false;
	  for (k = 0; k < canoneqf->size(); k++) {
	    if (checksol((*canoneqf)[k],numsols,RELERR) > 1) {
	      if (!discrep) {
		outFile << "<DISCREPANCIES>" << endl;
		discrep = true;
	      }
	      outFile << (*canoneqf)[k]->getInfix() << endl;
	    } // end of if checksol > 1
	  } // end of loop over k, equations to check
	  dimchkeqf(outFile);
	  // end of "should we do checking of solution here?"
	  // now prepare canongrads in prep for indy calls
	  canongrads->assign(canoneqf->size(),(valander *)NULL);
	  for (k = 0; k < canoneqf->size(); k++) {
	    (*canongrads)[k] = getvnd((*canoneqf)[k],canonvars,numsols);
	  }
	} // end of if solveeqs, check done only if solution seemed complete
	outFile.close();
      } //end of if (outFile)
      result = error[3];
    } // end of if (isOkay) 
    else result = error[1]; 
  }
  return result;
}

#if USE_TEMP_FILE
#define TEMP_FILE "andes241.tlz"
#endif
/************************************************************************
 * solveTheProblem							*
 *	Assumes the equations and variables have already been entered	*
 *	solves the problem, writing the solution in TEMP_FILE, 		*
 *	including the tags and problem statements if the problem was	*
 *	not completely solved.						*
 *   Then it opens the file for reading, and returns the first line	*
 *	[does not close file]						*
 ************************************************************************/
char* solveTheProblem() {
  int k;

#if !USE_TEMP_FILE
  std::string strResult;		// hold results in string
#endif 

  if (isFirst) throw string("solveTheProblem called before initialization");
  try {
#if USE_TEMP_FILE
     ofstream outFile(TEMP_FILE, ios::out);
#else
    std::ostringstream outFile(strResult); // stream results to string, not file
#endif
    if (outFile) {
      numsols->assign(canonvars->size(),HUGE_VAL);
      if (solveeqs(outFile)) {
	// should we do checking of solution here?
	bool discrep = false;
	for (k = 0; k < canoneqf->size(); k++) {
	  if (checksol((*canoneqf)[k],numsols,RELERR) > 1) {
	    if (!discrep) {
	      outFile << "<DISCREPANCIES>" << endl;
	      discrep = true;
	    }
	    outFile << (*canoneqf)[k]->getInfix() << endl;
	  }
	} // loop over equations to check
	dimchkeqf(outFile);
	// end of "should we do checking of solution here?"
      }
#if USE_TEMP_FILE
      outFile.close();
#endif
    } 
    else throw string("unable to create solution buffer");
  } 
  catch (string message) { throw message; } 
  catch (...) { throw string("solveTheProblem went boom!!"); }

  // this would be a good place to insert checksol ? or after returning
  // solution, in solveMoreOfTheProblem ?
  try {
#if USE_TEMP_FILE
     inFile.open(TEMP_FILE, std::ios::in);// | std::ios::binary);
#else
    std::istringstream inFile (strResult);	// get results from string
#endif
    inFile.clear();
    inFile.seekg(0);
    int tk;
    try { tk = inFile.eof(); } 
    catch (...) { throw string("eof?!?"); }
    if (! tk) {
      string t;
      try { t = getaline(inFile); } 
      catch (...) { throw string("getaline fails???"); }
      try { sprintf(lzbfr, "%s", t.c_str()); } 
      catch(...) { throw string("copy is wrong??"); }
      return lzbfr;
    } 
    else return error[4];
  } 
  catch (string message) { throw message; } 
  catch (...) { throw string("Read went bad!!"); }
  return error[3];
}

/************************************************************************
 * solveMoreOfTheProblem						*
 *	reads one line from the opened solution file, 			*
 *	if that line is empty, closes file, returns nil			*
 *	if not, returns it						*
 *	if EOF, closes file and returns nil				*
 *	I don't understand when is returns "So far so good"		*
 ************************************************************************/
char* solveMoreOfTheProblem() {
  try {
    if (! inFile.eof()) {
      string t = getaline(inFile);
      if (t.size() == 0) {
        inFile.clear();
#if USE_TEMP_FILE
	inFile.close();
#endif
	return error[4];	// if checksol after returning sol, here+below
      } // end of if line empty, which closes and returns
      else sprintf(lzbfr, "%s", t.c_str());
      return lzbfr;
    } // end of not eof. 
    else {
      inFile.clear();
#if USE_TEMP_FILE
      inFile.close();
#endif
      return error[4];	// if checksol after returning sol, here and above
    }
  } catch (string message) {
    inFile.clear();
#if USE_TEMP_FILE
    inFile.close();
#endif
    throw message;
  } catch (...) {
    inFile.clear();
#if USE_TEMP_FILE
    inFile.close();
#endif
    throw string("More went bad!!");
  }
  return error[3];
}


bool handleInput(std::string& aLine) {
  try {
    if (isFirst) doinitinit();
    bool result = true;
    if (!aLine.empty()) result = getall(aLine);
  return result; // Unexpected input
  } 
  catch (std::string message) { throw message; } 
  catch (...) { throw std::string("Handle Input is broke"); }
}

void indyEmpty();
bool clearTheProblem() {
  try {
    indyEmpty();
    isFirst = false;
    return true;
  }
  catch (std::string message) { throw message; } 
  catch (...) { throw std::string("Handle Input is broke"); }
}

extern bool setupdone;

void doinitinit() {
  try {
    isFirst = false;
    setupdone = false;
    indyEmpty(); 
  }
  catch (std::string message) { throw message; } 
  catch (...) { throw std::string("InitInit is broken"); }
}
