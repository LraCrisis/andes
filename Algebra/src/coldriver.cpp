// coldriver.cpp
// Copyright (C) 2001 by Joel A. Shapiro -- All Rights Reserved

//	solve equations for problem in Andes2,
//	from files generated by Collin, 1/29/01
//	Just as list2 but for new solver format
#define USE_TEMP_FILE  0 // use crufty temp file to communicate with ourself
#define IAmMain
#include <stdio.h>
#include "coldriver.h"
#include "extstruct.h"
#include "decl.h"
#include "unitabr.h"
#include "indyset.h"
#include "indysgg.h"
#include "dbg.h"
#if USE_TEMP_FILE
#include <fstream>
#else
#include <iostream>
#include <sstream>
#endif
#include "justsolve.h"
// int dbgnum;
bool handleInput(std::string& aLine);
void doinitinit();  // this is defined below
int checksol(const binopexp * const eqexpr, const vector<double> * const sols,
	     const double reltverr);
#if USE_TEMP_FILE
void dimchkeqf(ostream & outstr);
#else
void dimchkeqf(iostream & outstr);
#endif

extern vector<valander *> *canongrads;

bool isFirst = true;		// instantiation moved here by Linn
//////////////////////////////////////////////////////////////////////////////
// static/local error messages reurned for copying
static char* error[] = {
	"Unable to read source file",
	"Unable to write destination file",
	"Unexpected Input",
	"So far so good",
	"nil",
};
char lzbfr[4096]; // major kludge but this needs to be rewritten once
// it's in working anyway
#if USE_TEMP_FILE
std::ifstream inFile;
#else
stringstream resultBuffer;     // hold output in string buffer.
#endif

void constsfill();
extern unitabrs unittable;

#if USE_TEMP_FILE
#define TEMP_FILE "andes241.tlz"
#endif
/************************************************************************
 * solveTheProblem							*
 *	Assumes the equations and variables have already been entered	*
 *	solves the problem, writing the solution in TEMP_FILE, 		*
 *	including the tags and problem statements if the problem was	*
 *	not completely solved.						*
 *   Then it opens the file for reading, and returns the first line	*
 *	[does not close file]						*
 ************************************************************************/
char* solveTheProblem() {
  int k;


  if (isFirst) throw string("solveTheProblem called before initialization");
  try {
#if USE_TEMP_FILE
    ofstream outFile(TEMP_FILE, ios::out);
#else
#define outFile resultBuffer
    //  outFile.seekp(0);
     outFile.str(string());
#endif
    if(outFile) {
#if !USE_TEMP_FILE
      //      cout << "resultBuffer pointers="<<resultBuffer.tellp()<<" "
      //   <<resultBuffer.tellg()<<endl;
#endif
      numsols->assign(canonvars->size(),HUGE_VAL);
      if (solveeqs(outFile)) {
	// should we do checking of solution here?
	bool discrep = false;
	for (k = 0; k < canoneqf->size(); k++) {
	  if (checksol((*canoneqf)[k],numsols,RELERR) > 1) {
	    if (!discrep) {
	      outFile << "<DISCREPANCIES>" << endl;
	      discrep = true;
	    }
	    outFile << (*canoneqf)[k]->getInfix() << endl;
	  }
	} // loop over equations to check
	dimchkeqf(outFile);
	// end of "should we do checking of solution here?"
      }
 #if USE_TEMP_FILE
      outFile.close();
#else
      // outFile.seekp(0);
#endif
    } 
    else throw string("unable to create solution buffer");
  } 
  catch (string message) { throw message; } 
  catch (...) { throw string("solveTheProblem went boom!!"); }

  // this would be a good place to insert checksol ? or after returning
  // solution, in solveMoreOfTheProblem ?
  try {
#if USE_TEMP_FILE
     inFile.open(TEMP_FILE, std::ios::in);// | std::ios::binary);
#else
    resultBuffer.clear();
    resultBuffer.seekg(0);
#define inFile resultBuffer
#endif
    int tk;
    try { tk = inFile.eof(); } 
    catch (...) { throw string("eof?!?"); }
    if (! tk) {
      string t;
      try { t = getaline(inFile); }
      catch (...) { throw string("getaline fails???"); }
      try { sprintf(lzbfr, "%s", t.c_str()); } 
      catch(...) { throw string("copy is wrong??"); }
      return lzbfr;
    } 
    else return error[4];
  } 
  catch (string message) { throw message; } 
  catch (...) { throw string("Read went bad!!"); }
  return error[3];
}

/************************************************************************
 * solveMoreOfTheProblem						*
 *	reads one line from the opened solution file, 			*
 *	if that line is empty, closes file, returns nil			*
 *	if not, returns it						*
 *	if EOF, closes file and returns nil				*
 *	I don't understand when is returns "So far so good"		*
 ************************************************************************/
char* solveMoreOfTheProblem() {
  try {
    if (! inFile.eof()) {
      string t = getaline(inFile);
      if (t.size() == 0) {
        inFile.clear();
#if USE_TEMP_FILE
      inFile.close();
#else
      // inFile.seekg(0);
#endif
	return error[4];	// if checksol after returning sol, here+below
      } // end of if line empty, which closes and returns
      else sprintf(lzbfr, "%s", t.c_str());
      return lzbfr;
    } // end of not eof. 
    else {
      inFile.clear();
#if USE_TEMP_FILE
      inFile.close();
#else
      //   inFile.seekg(0);
#endif
      return error[4];	// if checksol after returning sol, here and above
    }
  } catch (string message) {
    inFile.clear();
#if USE_TEMP_FILE
      inFile.close();
#else
      // inFile.seekg(0);
#endif
    throw message;
  } catch (...) {
    inFile.clear();
#if USE_TEMP_FILE
      inFile.close();
#else
      // inFile.seekg(0);
#endif
      throw string("More went bad!!");
  }
  return error[3];
}


bool handleInput(std::string& aLine) {
  try {
    if (isFirst) doinitinit();
    bool result = true;
    if (!aLine.empty()) result = getall(aLine);
  return result; // Unexpected input
  } 
  catch (std::string message) { throw message; } 
  catch (...) { throw std::string("Handle Input is broke"); }
}

void indyEmpty();
bool clearTheProblem() {
  try {
    indyEmpty();
    isFirst = false;
    return true;
  }
  catch (std::string message) { throw message; } 
  catch (...) { throw std::string("Handle Input is broke"); }
}

extern bool setupdone;

void doinitinit() {
  try {
    isFirst = false;
    setupdone = false;
    indyEmpty(); 
  }
  catch (std::string message) { throw message; } 
  catch (...) { throw std::string("InitInit is broken"); }
}
