#|;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ODBC.cl
;; Collin Lynch
;; 5/9/2003
;;
;; The code in this file is used for ODBC data source access by the code in
;; HelpDriver.cl.  My purpose in locating it here was to centralize all of
;; the database functions for easy protability and for easy re-use by other
;; code.  
;;
;; This code assumes that the user is making use of an ODBC compliant data 
;; source.  It was written with a MySQL Database in mind although that could
;; in theory be replaced.  Some tweaks might be necessary.  
;;
;; The :Verbose arguments on each command will print out the SQL string that
;; is sent to the database if it is asked to do so. 
;;
;; The first function in this file is a simple qrapper for the dbi:sql func
;; it takes in a formatted sql string and executes it on the database returning
;; either a qresult or the raw values as returned by the allegro odbc driver
;; as necessary.
;;
;; The remaining functions are either odbc-format funcs which take in arguments and
;; return valid sql representing the supplied arguments or other functions that act
;; as wrappers for the selection and execution.  This split is done so that the
;; functions can be nested as necessary.
;;
;; In order to use this code one should call the associated format function and then
;; pass the string into the odbc-exec function or simply call the wrapper function.
;;
;; -----------------------------------------------------
;; Database utilities.
;; These functions directly access the database to carry out the commonly
;; needed tasks of the the funcs above.  All errors encountered will be
;; returned directly to the user.
;;
;; Most of the functions take both a database name and a connection struct.
;; The database name is a string indicating the database to be accessed.
;; The Connection Struct is a pointer struct generated by the ODBC code
;; both are necessary for access.
;;
;; The reason that I do not make use of the USE database code is that I want
;; this code to be as general as possible and Use is not SQL standard.  I 
;; also want to make functions that support the use of multiple databases.
;; The MySQL documentation does not list any efficiency advantages due to 
;; the USE so I am ignoring it for now.  In order to make it availible 
;; just uncomment the associated function.  
;;
;; -----------------------------------------------------
;; TODO::
;; 1. Determine what is and is not ANSI SQL in this code and flag it.
;; 2. Alter code that takes optional lists such as create-table for cols and
;;    lock tables to make it possible for a single value to be supplied.
;; 3. Support Alternate connection types and alternate databases.
;; 
|#


;;; -------------------------------
;;; Load AllegroODBC.
(require :aodbc-v2) 


;;;; ===================================================================
;;;; Connect and Disconnect

;;; ----------------------------------------------------------------
;;; Open a connection an ODBC client.
;;; This function takes a string specifying the name of an ODBC 
;;; service and attempts to open a connection with it.  If successful 
;;; it will return an ODBC Connection struct.  If it fails then it 
;;; will return an error.
;;;
;;; Arguments:
;;;  ODBCName:  The name of the odbc datasource (string) to be connected
;;;             to.  This name can be found in the datasources manager.
;;;  &key 
;;;   Verbose:   If t then the status will be echoed to stdout.
;;;
;;; Returns:  A database connection object or an error.

(defun odbc-connect (ODBCName &key (Verbose Nil))
  "Connect to the data source."
  (if Verbose (format t "ODBC:: Connecting to ~a ... " ODBCName))
  (let ((Connection (dbi:connect :data-source-name ODBCName)))
    (if Verbose (format t "Connected!~%"))
    Connection))


;;; -------------------------------------------------------------------
;;; Disconnect from the specified ODBC Datasource.
;;;  Arguments:
;;;   Connection:  The ODBC Connection to be closed.
;;;   &key 
;;;    Verbose:   If t then the call will be echoed to stdout.
;;;
;;; Returns: The connection object (now closed).

(defun odbc-disconnect (Connection &key (Verbose Nil))
  "Disconnect from the specified database."
  (if Verbose (format t "ODBC:: Disconnecting ODBC Source.~%")) 
  (dbi:disconnect Connection))



;;;; ==================================================================
;;;; Execution
;;;; The functions in this section is used as a wrapper to the dbi:sql 
;;;; method that is used to execute sql strings.  This code executes
;;;; the sql string on the specified server connection and will return
;;;; a qresult if the specified flag is supplied.


;;; --------------------------------------------------------------------------
;;; Query result struct and functions.

(defstruct Qresult
  Headers
  Query)

(defun Qresult-nextline (Q &optional (Eof-Errorp Nil) (Eof-Val Nil))
  "Pull the next resultline from the Qresult."
  (dbi:fetch-row (Qresult-Query Q) Eof-Errorp Eof-Val))

(defun close-Qresult (Q)
  "Close the specified qresult freeing the memory."
  (dbi:close-query (Qresult-Query Q)))

;;; Given a sql statement and a set of flags that specify its behavior,
;;; execute the sql command on the specified connection returning a 
;;; qresult or the values according to the supplied arguments.
;;;
;;; Args:
;;;  SQL:  The Sql string to be executed.
;;;  Connection:  The odbc connection to be used.
;;;  &key
;;;   Types:  A list of type specifiers to be used in translating the 
;;;           result if such translation is necessary.  This should be
;;;           used for select statements primarily.
;;;   Qresult:  If t the result of any selects will be returned as a Qresult
;;;             If nil then the results will be propogated back as-is.
;;;   Verbose:  If t then the sql will be echoed to the user before being
;;;             executed.

(defun odbc-exec-sql (Sql Connection &key (Types Nil) (Qresult Nil) (Verbose Nil))
  "Execute the specified Sql string returning a qresult if necessary."
  (if Verbose (format t "ODBC:: ~a~%" Sql))
  (if (not Qresult) (dbi:sql Sql :db Connection :Types Types)
    (multiple-value-bind (Query Header)
	(dbi:sql Sql :db Connection :Types Types :query t)
      (make-Qresult :Headers Header :Query Query))))






;;;; ==================================================================
;;;; Databases.

;;; -------------------------------------------------------------------
;;; Show Databases
;;; Return a list of the databases that are on the server.
;;;
;;; Arguments:
;;;  Connection:  The odbc-connection object.
;;;  &key
;;;   Verbose: if t then the sql call will be echoed to stdout.

(defun odbc-show-dbs (Connection &key (Qresult Nil) (Verbose Nil))
  (odbc-exec-sql "SHOW DATABASES" Connection 
		 :Qresult Qresult :Verbose Verbose))


;;; -------------------------------------------------------------------
;;; Check to see if the specified Database exists on the ODBC service
;;; This code makes use of the SHOW DATABASES call.  
;;; Arguments:
;;;  DBName:      The database to be used.
;;;  Connection:  The ODBC Connection object.
;;;  &key 
;;;   Verbose:   If t then the sql call will be echoed to stdout.
;;;
;;; Returns: The name of the database if so nil otherwise.
;;;
;;; WARNING:: I am not certain that this code is compatible with the 
;;; SQL standard so it may be necessary to find a different route 
;;; depending upon the server being used. 
(defun odbc-db-exists? (DBName Connection &key (Verbose Nil))
  "Return t if the specified database exists."
  (let ((R (odbc-exec-sql "SHOW DATABASES" Connection :Verbose Verbose)))
    (if (not (member DBName R :key #'car :test #'string-equal))
	(if Verbose (format t "ODBC:: ~a Does Not Exist!~%" DBName))
      (progn (if Verbose (format t "ODBC:: ~a Exists!~%" DBName)) 
	     DBName))))
  

;;; -----------------------------------------------------------------
;;; Attempt to create a new database with the specified name at
;;; the other end of the ODBC Connection.  
;;; Arguments:
;;;  DBName:      The database name to be used.
;;;  Connection:  The database connection.
;;;  &key 
;;;   IF-not-Exists: If t then the system will create the database iff 
;;;         the database does not already exist.  If nil then the 
;;;         system will attempt to create it and thow an error if it 
;;;         already exists.
;;;   Verbose:   If t then the sql call will be echoed to stdout.
;;;
;;; Returns: T if the creation succeeds or an error otherwize.
;;; 
;;; NOTE:: This may not be SQL standard's compliant.
(defun odbc-format-create-db (DBName &key (IF-not-exists Nil))
  (format Nil "CREATE DATABASE ~a~a" 
	  (if If-not-exists "IF NOT EXISTS " "") 
	  DBName))


(defun odbc-create-db (DBName Connection &key (if-not-Exists Nil) (Verbose Nil))
  "Create A database with the specified name in the connection."
  (if Verbose (format t "ODBC:: Creating DB ~a ~a~%" DBName if-Exists))
  (odbc-exec-sql (odbc-format-create-db DBName :If-Not-Exists If-Not-Exists)
		 Connection :Verbose Verbose))

;;; ------------------------------------------------------------------
;;; Attempt to drop the specified database from the database server.
;;; NOTE:: This may not be ANSI standard.
;;; Arguments:
;;;  DBName:  The database name to be used.
;;;  Connection:  The database to be connected to.
;;;  &key
;;;   IF-Exists:  A flag that if t will cause the drop command to be 
;;;               conditional on the database already existing thus
;;;               preventing errors.
;;;   Verbose:   If t then the sql call will be echoed to stdout.
;;;
;;; Returns: t if the drop succeds (or the if-exists is supplied 
;;;    and the database does not exist) or an error.

(defun odbc-format-drop-db (DBName &key (IF-Exists Nil))
  (format Nil "DROP DATABASE ~a~a" (if If-exists "IF EXISTS " "") DBName))
  
(defun odbc-drop-db (DBName Connection &key (IF-Exists Nil) (Verbose Nil))
  (odbc-exec-sql (odbc-format-drop-db DBName :IF-Exists IF-Exists)
		 Connection :Verbose Verbose))


;;; -----------------------------------------------------------------
;;; Set the specified database at the other end of the connection 
;;; to be the current active database for all calls unless otherwize
;;; specified.
;;;
;;; This is not SQL standard and it's use appears to provide no 
;;; benefits in terms of speed or efficiency so I have commented 
;;; it out for now.
;;(defun db-use-database (DBName Connection)
;;  "Switch to using the specified database."
;;  (dbi:sql (format Nil "USE ~a" DBName) :db Connection))





;;;; =========================================================================
;;;; Tables

;;; ----------------------------------------------------------------------
;;; Show tables
;;; Given a database name show the tables that are in the database returning
;;; the results as a qresult or a pair of lists.
;;;
;;; Arguments:
;;;  DBName: Database name.
;;;  Connection:  The odbc-connection object.
;;;  &key
;;;   Verbose: if t print the sql to stdout.

(defun odbc-format-show-tables (DBName)
  (format Nil "SHOW TABLES FROM ~a" DBName))


(defun odbc-show-tables (DBName Connection &key (Qresult Nil) (Verbose Nil))
  (odbc-exec-sql (odbc-format-show-tables DBName)
		 Connection :Qresult Qresult :Verbose Verbose))


;;; ----------------------------------------------------------------------
;;; Table testing
;;; Given an open connection, a DBName and a table name test to see if 
;;; the specified table exists and return t or nil appropriately.
;;;
;;; Arguments:
;;;  TableName:  A string-form table name.
;;;  DBName:  A string-form database name.
;;;  Connection:  An open connection object.
;;;
;;; Returns: t or nil if failed.

(defun odbc-table-exists? (TableName DBName Connection &key (Verbose Nil))
  (member TableName (odbc-show-tables DBName Connection :Verbose Verbose)
	  :key #'car :test #'string=))
  


;;; ------------------------------------------------------------------
;;; columns in a table
;;; Show the columns from the specified table and database.
;;;
;;; Arguments:
;;;  TableName: A string-form table name.
;;;  DBName:    A string-form db name.
;;;  Connection: An ODBC connection object.
;;;  &key
;;;   Verbose: If t the sql will be echoed to the screen.

(defun odbc-format-show-columns (Table DBName)
  (format Nil "SHOW COLUMNS FROM ~a.~a" DBName Table))

(defun odbc-show-columns (Table DBName Connection &key (Qresult Nil) (Verbose Nil))
  (odbc-exec-sql (odbc-format-show-columns Table DBName)
		 Connection :Qresult Qresult :Verbose Verbose))





;;; ------------------------------------------------------------------
;;; Create table.
;;; Database tables are defined by their name, the database that they are
;;; a part of, a list of column specs, and any indicies that were defined
;;; on them.  The code in this section can be used to create a table
;;; given a set of column and index specs, and the create the specs 
;;; themselves.  
;;;
;;; The first function in this section is used to form individual column 
;;; specs.  The second is used to form a list of identical specs from a
;;; list of names and some keyword values.
;;;
;;; The third function is used to form lock specs.
;;; The fourth function is used for format a complete create table spec.
;;; The final function is a wrapper for the format and execution.  


;;; Format Columnspec
;;; A column spec is a string that can be included in any sql cmd that
;;; creates a table.  For MySQL the sring is of the form:
;;;   "<Name> <Type> [<Options>]"  where:
;;;  Name is a string less than 64 chars in length that can be used as a colname.
;;;  Type is one of the legal sql types such as Integer or Char.
;;;  Options is a set of option statements such as "PRIMARY KEY"
;;;  Currently the code supports the following options (sepcified as keys).
;;;   "NOT NULL"       If set to t then the column can never be Null.
;;;   "DEFAULT"        If a value is supplied (as a str or atom) then it will 
;;;                       be the column default.  If it is not supplied then 
;;;                       the defualt val will be NULL or a value set by the
;;;                       column type if NOT NULL is t.
;;;   "PRIMARY KEY"    If t then the column will be designated as the primary key.
;;;   "AUTO_INCREMENT" If t then the column must be an integer and will be set to
;;;                       increment to the next highter value with each new null entry.
;;;     At a later point I may add support for the reference_definition feature.

(defun odbc-format-columnspec (Name Type 
			       &key (Not-Null Nil) (Default Nil)
				    (Auto-Increment nil) (primary-Key Nil)) 
  "Create a column spec."
  (concatenate 'string 
    (format Nil "~a ~a" Name Type)
    (if Not-Null " NOT NULL" "")
    (if Default (format Nil " DEFAULT ~A" Default) "")
    (if Auto-Increment " AUTO_INCREMENT" "")
    (if Primary-Key " PRIMARY KEY" "")))
    


;;; Format-list-columnspecs
;;; Given a list of column names and a type as well as any key values generate
;;; a list of column specifiers that have each name, are of the specified types 
;;; and have the same keyvalues.  

(defun odbc-format-list-columnspecs (Names Type &key (Not-Null Nil) (Default Nil))
  (mapcar #'(lambda (Name) 
	      (odbc-format-columnspec 
	       Name Type :Not-Null Not-Null :Default Default))
	  Names))




;;; Create Index Spec
;;; Indexes are defined by a name and a list of columns within the
;;; index itself.  These will be printed as a string that can then be passed
;;; to the sql spec.  The arguments are:
;;;  Name: a string that will be used for the index name.
;;;  Columns: a non-null list of columns that will be in the index.

(defun odbc-format-indexspec (Name Columns)
  "Create an Index Spec."
  (format Nil "INDEX ~a (~a~{, ~a~})" Name (car Columns) (cdr Columns)))


;;; format-create-table
;;; Generate a table containing the specified columns and indicies
;;; in the database named over the ODBC connection supplied.
;;; The args are:
;;;  DBName:  A Database name as a string.
;;;  Connection:  An ODBC Connection object.
;;;  Columns:  A list of column specs returned by db-create-columnspec
;;;  &key 
;;;   Indicies: A list of index specs returned by db-create-indexspec
;;;   IFExists: An atom indicating what should be done if the specified
;;;             table already exists.  This is one of:
;;;              :Error (default) throw an error.
;;;              :Overwrite remove the table and then re-create it.
;;;              :Append If the table exists leave as is, if not then
;;;                      create it.
;;;   Verbose:   If t then the sql call will be echoed to stdout.
;;;
;;; Returns:  T if the call succeeds or an error otherwize.
;;;
;;; NOTE:: To avoid data corruption the sysytem assumes that if 
;;;  you choose :Append you know what you are doing.

(defun odbc-format-create-table (TableName DBName Columns 
				 &key (Indicies Nil) (If-Not-Exists Nil))
  (format Nil "CREATE TABLE ~a~A.~A (~A~{, ~A~}~{, ~A~})"
	  (if If-Not-Exists "IF NOT EXISTS " "")
	  DBName TableName (car Columns) (cdr Columns) Indicies))




;;; Create-table
;;; Given the a set of arguments for table specification including a database connection
;;; generate the specified table.
;;; 
;;; Arguments:
;;;  DBName:  A Database name as a string.
;;;  Connection:  An ODBC Connection object.
;;;  Columns:  A list of column specs returned by db-create-columnspec
;;;  &key 
;;;   Indicies: A list of index specs returned by db-create-indexspec
;;;   If-Not-Exists:  If t then the sysytem will only try to create the 
;;;         table if one of the same name does not exist.  If it is nil
;;;         then the sysytem will try to create it and throw an error if
;;;         it already exists.
;;;   Verbose:   If t then the sql call will be echoed to stdout.
;;;
;;; Returns:  T if the call succeeds or an error otherwize.
;;;
;;; NOTE:: To avoid data corruption the sysytem assumes that if 
;;;  you choose :Append you know what you are doing.

(defun odbc-format-create-table (TableName DBName Columns 
				 &key (Indicies Nil) (if-not-exists Nil))
  "Format the create-table sql string."
  (format Nil "CREATE TABLE ~A~A.~A (~A~{, ~A~}~{, ~A~})"
	  (if If-Not-Exists "IF NOT EXISTS " "")
	  DBName TableName (car Columns) (cdr Columns) Indicies))


(defun odbc-create-table (TableName DBName Connection Columns 
			  &key (Indicies Nil) (if-not-exists Nil)
			       (Verbose Nil))
  "Create the table with the specified properties in the database."
  (odbc-exec-sql 
   (odbc-format-create-table 
    TableName DBName Columns :Indicies Indicies :If-Not-Exists If-not-exists)
   Connection :Verbose Verbose))
  


;;; -----------------------------------------------------------------------
;;; Drop Table
;;; Eliminate the specified table from the database.
;;;
;;; Args:
;;;  TblName:     The name of the table to be dropped.
;;;  DBName:      The Database the table is present in.
;;;  Connection:  The ODBC Connection.
;;;  &key
;;;   IF-Exists:  If t then the system will only try to drop
;;;               the table if it exists and not throw an error
;;;               if it does not.
;;;   Verbose:    If t the SQL command will be executed.
;;;
;;; Returns:  T if it succeeds nil otherwise.

(defun odbc-format-drop-table (Table DBName &key (IF-Exists Nil))
  "Format the drop-table sql string."
  (format Nil "DROP TABLE~a~a.~a"
	  (if IF-Exists " IF EXISTS " " ")
	  DBName Table))


(defun odbc-drop-table (TableName DBName Connection
			&key (IF-Exists Nil) (Verbose Nil))
  "Drop the table if necessary."
  (odbc-exec-sql (odbc-format-drop-table TableName DBName :IF-Exists IF-Exists)
		 Connection :Verbose Verbose))



;;;; ----------------------------------------------------------------------
;;;; Table Locking
;;;; When a select or insert is executed on a database it is necessary to 
;;;; lock the individual tables being dealt with.  MySQL and other databases
;;;; will automatically lock the table when a command is issued.  However 
;;;; this has some cost.  Manually locking the tables before a long series 
;;;; of reads and writes can increae the throughput. 
;;;;
;;;; Lock can also be used to ensure that no modifications will be made 
;;;; to a table during a long series of reads and writes.  This same guard 
;;;; can also be handled using transactions if necessary.
;;;;
;;;; In order to lock a given table the user must format a lock-spec for it
;;;; consisting of a tablename, a database name, and a lock type.  The type 
;;;; is one of:
;;;;  :Read        Lock the table for all modifications inside and outside MySQL
;;;;  :Read-Local  This locks tha table for read but permits 'non-conflicting'
;;;;               Insert statements to occur at the same time.  
;;;;  :Write       Lock the table so that you can write to it.  This has a higher
;;;;               priority than read and should prevent any other thread from
;;;;               obtaining a read or write lock on the table.
;;;;  :Write-Low   This requests a "low-priority" write lock meaning that you
;;;;               Wish to write to the table but are polite enough to wait 
;;;;               untill all of the other read locks in the queue are finished
;;;;               before stepping in, how nice of you.
;;;;
;;;; The locking code takes in a list of ids as keyword arguments and returns
;;;; a sql string that will lock the specified tables according to their types.
;;;; This is being done this way becuase MySQL automatically releases all other
;;;; locks that are held by a process when a table lock is issued.  Therefore,
;;;; If you intend to lock several tables you must issue the locks as a group.

(defun odbc-format-lock-tables (&key (Read Nil) (Read-Local Nil) 
				     (Write Nil) (Write-Low Nil))
  "Format a lock-tables request."
  (let ((lst (append 
	      (odbc-format-lock-list Read "READ")
	      (odbc-format-lock-list Read-Local "READ LOCAL")
	      (odbc-format-lock-list Write "WRITE")
	      (odbc-format-lock-list Write-Low "LOW_PRIORITY WRITE"))))
    (format Nil "LOCK TABLES ~a~{, ~a~}" (car Lst) (cdr Lst))))
	    


;;; Given an id, or list of ids and a lock type format a lock spec
;;; for the id(s) of the specified type.
(defun odbc-format-lock-list (IDs Type)
  "Format locks for the specified types."
  (if (not (listp IDs)) (list (format Nil "~a ~a" IDs Type))
    (mapcar #'(lambda (ID) (format Nil "~a ~a" ID Type)) IDs)))



(defun odbc-lock-tables (Connection 
			 &key (Read Nil) (Read-Local Nil)
			      (Write Nil) (Write-Low Nil)
			      (Verbose Nil))
  (odbc-exec-sql 
   (odbc-format-lock-tables 
    :Read Read 
    :Read-Local Read-Local
    :Write Write 
    :Write-Low Write-Low)
   Connection :Verbose Verbose))



;;;; ---------------------------------------------------------------------
;;;; Unlock tables.
;;;; Release all of the locks that have been obtained by the current 
;;;; thread.  Argument:
;;;;  Connection:  The ODBC data source to be unlocked.
;;;;  &key
;;;;   Verbose:    If t the system will echo the call to the user.
;;;;
;;;; Returns: T if the call succeeded, error otherwize.
;;;;
;;;; NOTE:: Other calls to lock tables or to ODBC-Disconnect will also
;;;;        unlock all the tables so this is only necessary if we intend
;;;;        to re-use a connection or want to allow other processes through.
(defun odbc-format-unlock-tables () "UNLOCK TABLES")

(defun odbc-unlock-tables (Connection &key (Verbose Nil))
  (odbc-exec-sql "UNLOCK TABLES" Connection :Verbose Verbose))


;;;; ---------------------------------------------------------------------
;;;; Insert into table.
;;;; Given a tableid, a connection, and a set of column names insert one 
;;;; or more records into the table setting each value to the appropriate
;;;; column value.
;;;;
;;;; If one or more records are supplied then each item N in the record
;;;; is assumed to be a value for the Nth Column that was listed.  It 
;;;; must be of the appropriate type to be included.  
;;;;
;;;; If a sql select is supplied then the nth column of the recordset that
;;;; is returned by it must correspond to the nth column in the columns 
;;;; list.  
;;;;
;;;; The keywords :Record :Records and :Select will be used in that order
;;;; 
;;;; Arguments: 
;;;;   TableName:  The table name to be inserted into.
;;;;   DBName:     The database to be updated.
;;;;   Connection: The ODBC Connection to be used.
;;;;   Columns:    The column names to be used.
;;;;   
;;;;   &key
;;;;    Record:    A single list of values to be inserted as a record.
;;;;    Records:   A list of lists of values to be inserted. if 
;;;;               :Record is null
;;;;    Select:    A sql select string that will return the values 
;;;;               that we wish to insert. if :Records is nil.
;;;;    Verbose:   If t then the sql call will be echoed to stdout.
;;;;
;;;; Returns: t if successful error otherwize.

(defun odbc-format-insert (TableName DBName 
			   &key (Columns Nil) (Record Nil) (Records Nil) (Select Nil))				
  "Format the insert statement to the database."
  (format Nil "INSERT INTO ~a.~a ~a~a"
	  DBName TableName 
	  (if (null Columns) ""
	    (if (not (listp Columns)) (format Nil "(~a) " Columns)
	      (format Nil "(~a~{, ~a~}) " (car Columns) (cdr Columns))))
	  (cond (Record (format Nil "VALUES ~a" (odbc-format-insert-record-i Record)))
		(Records 
		 (let ((Lst (mapcar #'odbc-format-insert-record-i Records)))
		   (format Nil "VALUES ~a~{, ~a~}" (car Lst) (cdr Lst))))
		(Select Select))))



(defun odbc-format-insert-record-i (Record)
  "Format a record for insertion into the database."
  (format Nil "(~a~{, ~a~})"
	  (odbc-format-val (car Record))
	  (mapcar #'odbc-format-val (cdr Record))))



(defun odbc-insert (TableName DBName Connection 
		    &key (Columns Nil) (Record Nil) (Records Nil) (Select Nil) (Verbose Nil))
  "Format and then execute the supplied insert statement."
  (odbc-exec-sql 
   (odbc-format-insert 
    TableName DBName :Columns Columns :Record Record :Records Records :Select Select)
   Connection :Verbose Verbose))




;;;; -----------------------------------------------------------------------
;;;; Load Data Infile.
;;;; For efficiency reasons it might be more beneficial to store the results
;;;; of a process in a local file and then to upload that file to the database
;;;; this reduces the time taken to process each record and allows the database
;;;; server the luxure of coping with a single large transaction.  
;;;;
;;;; The specified table must already exist and must contain the same number 
;;;; and type of the supplied file, or the user must supply the optional list
;;;; of column names.
;;;;
;;;; NOTE:: Load Data INFile may not be SQL standard.  The code here is based
;;;;  Upon MySQL's form.  For portability reasons it may be necessary to 
;;;;  change this.
;;;;
;;;; NOTE:: The behavior of load data infile differs on windows 
;;;;
;;;;
;;;; Arguments:
;;;;  Filename:  The file or pathname to be loaded from.
;;;;  TableName: The destination table.
;;;;  &key
;;;;   Local:  If t the sysytem will look for the file on the user's 
;;;;      machine.  If it is not specified then the sysytem will search
;;;;      on the database server.
;;;;   Field-Term:     The character used to separate fields.  Defaults to \t
;;;;   Field-Enclose:  The character's used to enclose a field Default is #\'
;;;;   Field-Encl-opt: If t the value of Field-Enclose will be treated as
;;;;   Lines-Term:     The character used to terminate the lines.

(defun odbc-format-load-infile (Filename DBName TableName
				&key (Columns Nil) (Local Nil) (Field-Term Nil)
				     (Field-Encl Nil) (Field-Encl-Opt Nil)
				     (Field-Esc Nil) (Lines-term Nil)
				     (Ignore-Lines Nil))
  "Format a Load-Data-Infile sql command."
  (format Nil "LOAD DATA ~aINFILE '~a' INTO TABLE ~a.~a ~a ~a ~a ~a"
	  (if Local "LOCAL " "") FileName DBName TableName
	  (odbc-fli-format-field-terms Field-Term Field-Encl Field-Encl-Opt Field-Esc)
	  (if Lines-Term (format Nil "LINES TERMINATED BY '~a'" Lines-Term) "")
	  (if Ignore-Lines (format Nil "IGNORE ~a LINES" Ignore-Lines) "")
	  (if Columns (format Nil "(~a~{, ~a~})" (car Columns) (cdr Columns)) "")))

	  
(defun odbc-fli-format-field-terms (Field-Term Field-Encl Field-Encl-Opt Field-Esc)
  "Format the optional fields string of the load-data-infie sql command."
  (if (not (or Field-Term Field-Encl Field-Esc)) ""
    (format Nil "FIELDS ~a ~a ~a"
	    (if Field-Term (format Nil "TERMINATED BY '~a'" Field-Term) "")
	    (if (not Field-Encl) "" 
	      (format Nil "~aENCLOSED BY '~a'" 
		      (if Field-Encl-Opt "OPTIONALLY " "") 
		      Field-Encl))
	    (if Field-Esc (format Nil "ESCAPED BY '~a'" Field-Esc) ""))))
	    


(defun odbc-load-infile (FileName DBName TableName Connection 
			 &key (Columns Nil) (Local Nil) (Field-Term Nil)
			      (Field-Encl Nil) (Field-Encl-Opt Nil)
			      (Field-Esc Nil) (Lines-term Nil)
			      (Ignore-Lines Nil) (verbose Nil))
  "Execute a load-data-infile command on the specified db."
  (odbc-exec-sql 
   (odbc-format-load-infile
    FileName DBName TableName
    :Columns Columns 
    :Local Local 
    :Field-Term Field-Term
    :Field-Encl Field-Encl
    :Field-Encl-Opt Field-Encl-Opt
    :Field-Esc Field-Esc
    :Lines-Term Lines-Term
    :Ignore-Lines Ignore-Lines)
   Connection
   :Verbose Verbose))





;;;; -----------------------------------------------------------------------
;;;; Select from Table
;;;; The format for a select is as follows:
;;;;    SELECT <columns> 
;;;;    FROM <tables> 
;;;;    [WHERE <clause>]
;;;;
;;;; Sql selects take a list of column references and a list of keyword 
;;;; args.  The select will then be executed on the database.  The results
;;;; will be returned as a qresult struct containing two fields.  The first
;;;; is a list of column headers containing the column names for the result.
;;;; The second is a quiery object that can be probed to return the rest
;;;; of the results.  
;;;;
;;;; Arguments:
;;;;  Columns:  A list of formatted Column IDs for later use. (odbc-format-id)
;;;;
;;;;  Tables:   A list of formatted table IDs for later use. (odbc-format-id)
;;;;
;;;;  Connection:  An open ODBC Connection object.
;;;;
;;;;  &key
;;;;   Where:  A formatted where clause produced by odbc-format-where.
;;;;
;;;;   Group-By:  An id or list of ids to group the results by.  This is used to
;;;;              collapse several rows into a single row.  Note that this will
;;;;              effect the meaning of each row value.  
;;;;
;;;;              The contents of the list will be included in the sql statement
;;;;              in order.  If the keyword value :DESC appears in the list then
;;;;              the next item supplied will be sorted in Descending not ascending 
;;;;              order.  
;;;;
;;;;   Order-By:  An atomic function/id or list of functions/ids that will be used 
;;;;              to sort the results.  As with the Group-By keyword the :DESC key
;;;;              can be included to alter the way in which the sort occurs.  
;;;;
;;;;   Limit:     A maximum number of rows to be returned.  
;;;;
;;;;   Limit-Offset:  An offset for the number of rows to be returned if offset
;;;;                  N is specified then the sysytem will read <Limit> rows 
;;;;                  starting at the Nth row (where the first row is zero).
;;;;
;;;;   Types:  A list of external types for the columns one per column.  For
;;;;           Each type(N) that is supplied the system will read column(N)
;;;;           as an atom of that type.
;;;;
;;;;   Query:  If t then the system will return a query object.  
;;;;           If nil then it will return a list of lists.
;;;;   
;;;;
;;;;   Verbose:  If t the sql string will be echoed.
;;;;
;;;; Returns:  A QResult struct.
;;;;
;;;; NOTE:: The group-by clauses allow us to combine multiple rows into a single
;;;;  result record.  However the behavior of those records differ.  If you supply
;;;;  a group-by clause and a list of column ids to a select then the resulting 
;;;;  records will list the first value encountered in each group.  
;;;;
;;;;  Thus, if a select statment returns the following:
;;;;   ((0, 1, 2)
;;;;    (0, 4, 5)
;;;;    (0, 7, 8))
;;;;  Then a select that groups the reocrds by the first value will return the
;;;;  following:  (0, 1, 2) whether or not Group-By-Desc is supplied.  In order
;;;;  to obtain the values of more columns in the results you must make use of 
;;;;  functions such as count(id) and sum(id).  These are listed in the MySQL
;;;;  manual and some of them are also supplied below for easy formatting.
;;;;

(defun odbc-format-select (Columns Tables 
			   &key (Remove-duplicates Nil) (Where Nil)
				(Group-By Nil) (order-by Nil)
				(limit Nil) (limit-offset Nil))
  "Format the supplied select statement."
  (format Nil "SELECT ~a ~a FROM ~a~a~a~a~a"
	  (if Remove-Duplicates "DISTINCT" "ALL") 
	  (if (not (listp Columns)) (format Nil "~a" Columns)
	    (format Nil "~a~{, ~a~}" (car Columns) (cdr Columns)))
	  (if (not (listp Tables)) (format Nil "~a" Tables)
	    (format Nil "~a~{, ~a~}" (car Tables) (cdr Tables)))
	  (if Where (format Nil " WHERE ~a" Where) "")
	  (odbc-format-select-blist Group-By " GROUP BY")
	  (odbc-format-select-blist Order-By " ORDER BY")
	  (cond ((null Limit) "")
		((null limit-offset) (format Nil " LIMIT ~a" Limit))
		(t (format Nil " LIMIT ~a, ~a" Limit-Offset Limit)))))
	  

(defun odbc-format-select-blist (Lst Prefix)
  (cond ((null Lst) "")
	((not (listp Lst)) (format Nil "~a ~a" Prefix Lst))
	(t (let ((R (format Nil "~a ~a" Prefix (car Lst))))
	     (dolist (L (cdr Lst))
	       (if (equalp L :DESC) 
		   (setq R (concatenate 'string R " DESC"))
		 (setq R (concatenate 'string R (format Nil ", ~a" L)))))
	     R))))


;;; ---------------------------------------------------------------------
;;; Execute the select function.
;;;
;;; The keyword Remove-Duplicates controlls whether or not duplicate rows will be 
;;; returned or not.
(defun odbc-select (Columns Tables Connection 
		    &key (Remove-Duplicates Nil) (Where Nil) 
			 (Group-By Nil) (order-by Nil) 
			 (limit Nil) (limit-offset Nil)
			 (Types Nil) (Qresult Nil) (verbose Nil))
  "Select from the database."
  (odbc-exec-sql
   (odbc-format-select 
    Columns Tables 
    :Remove-Duplicates Remove-Duplicates
    :Where Where
    :Group-By Group-By
    :Order-By Order-By
    :Limit Limit
    :Limit-Offset Limit-Offset)
   Connection
   :Types Types
   :Qresult Qresult
   :Verbose Verbose))



;;;; ====================================================================
;;;; Union
;;;; The union command takes two or more sql select commands and returns
;;;; the union of their results.  In order for the statement to be valid 
;;;; all of the select queries must have the same number and types of 
;;;; columns returned.  The column headers from the first select command
;;;; will be the ones used.  The code in this section is used to format
;;;; a union command and to execute it as necessary.
;;;;
;;;; (Untested)

(defun odbc-format-union (Selects &key (All Nil))
  (let ((Str (format Nil "~a" (car Selects))))
    (dolist (Sql (cdr Selects))
      (setq Str
	(format Nil "~a UNION ~a~a" Str (if All "ALL " "") Sql)))
    Str))


(defun odbc-union (Selects Connection 
		   &key (All Nil) (Types Nil) (Qresult Nil) (Verbose t))
  "Format and execute the specified union statement."
  (odbc-exec-sql
   (odbc-format-union Selects :All All) Connection
   :Types Types
   :Qresult Qresult
   :Verbose Verbose))

;;;; ====================================================================
;;;; Formatting Utilities.
;;;; The functions below are used to format various arguments for use
;;;; by the system
;;;;
;;;; Some of them such as odbc-format-val are used internally and externally
;;;; some are not.  This is a hack I know but tough.


;;; --------------------------------------------------------------------
;;; odbc-format-func
;;; Given a function name and one or more values format the list 
;;; appropriately.  
(defun odbc-format-func (fname &rest Args)
  (format Nil "~a(~a~{, ~a~})" Fname (car Args) (cdr Args)))


;;; --------------------------------------------------------------------
;;; odbc-format-relation
;;; Given an infix or relation and two or more elements return a 
;;; string formatting the relations between them. If only one arg is 
;;; supplied then the relation will be printed as a prefix relation.
(defun odbc-format-rel (Relation &rest Args)
  "Format the infix relationship."
  (if (null (cdr Args)) (format Nil "~a" (car Args))
    (concatenate 'string
      (format Nil "~a ~a " (car Args) Relation)
      (apply #'odbc-format-rel Relation (cdr Args)))))


;;; -------------------------------------------------------------------
;;; Format a prefix relation
;;; Given a unary prefix relation format it and return the result.
(defun odbc-format-prefix (Relation Arg)
  (format Nil "~a ~a" Relation Arg))


;;; --------------------------------------------------------------------
;;; Format Values
;;; Given a "value" format it for transmission to the odbc database.  
;;; This should be realtively simple.  The only caveat is that we have 
;;; to deal with special escape chatacters in strings noteably pathnames.    
(defun odbc-format-val (Val)
  (format Nil "\'~a\'" 
	  (if (stringp Val) 
	      (odbc-quote-special-characters Val)
	    Val)))


(defun odbc-quote-special-characters (string)
  (loop for i from 0 to (1- (length string))
      with special = '(#\\)
      appending
	(let ((c (char string i)))
	  (if (member c special) (list #\\ c)
	    (list c)))
      into newstring
      finally (return (concatenate 'string newstring))))





;;; ------------------------------------------------------------
;;; Format an ID.
;;; Format a dot-separated id of the column and table ids.
;;;
;;; NOTE:: Case sensitivity is an issue in the database code
;;;  MySQL is case-insensitive for all Column Names but 
;;;  case-sensitive for database and table names on all platforms
;;;  BUT Windows unless the 'lower_case_table_names' flag is set.
;;;
;;;  The format ID code makes no attempt to set the case of the
;;;  incoming elements, only ensuring that they are, in fact,
;;;  strings.  I leave that up to the user as I do with all the 
;;;  other naming code.

(defun odbc-format-id (&key (DB Nil) (Tbl Nil) (Col Nil))
  (if (and db Col (null Tbl)) (error "ODBC:: Badly formed ID")
    (concatenate 'string
      (if DB (format Nil "~a" DB) "")
      (if (and DB TBL) "." "")
      (if Tbl (format Nil "~a" Tbl) "")
      (if (and TBL Col) "." "")
      (if Col (format Nil "~a" Col)))))


;;; -----------------------------------------------------------------
;;; Format a list of tableids
;;; Given a list of tablenames and a dbname format a list of tableids.
(defun odbc-format-tableids (DBName Tables)
  "Format a list of tableids."
  (mapcar #'(lambda (Tbl) (odbc-format-id :DB DBName :Tbl Tbl)) Tables))


;;; -----------------------------------------------------------------
;;; Format a list of column ids
;;; Given a dbname and a table name and a list of column names format 
;;; a list of table ids.
(defun odbc-format-colids (DBName Table Columns)
  "Format a list of tableids."
  (mapcar #'(lambda (Col) (odbc-format-id :DB DBName :Tbl Table :Col Col)) Columns))

;;; -----------------------------------------------------------------
;;; format infix wc.
;;;
;;; Complex where clauses are difficult so for now I have just this
;;; simple function.  More will be done later as necessary.
;;;
;;; Given a Relation and two formatted IDs produce a formatted infix
;;; relation for use in a select statement.
;;(defun odbc-format-infix-wc (Relation ID1 ID2 &rest OtherIDs)
;;  "Format the infix clauses."
;;  (let ((R (format Nil "~a ~a ~a" ID1 Relation ID2)))
;;    (if (null OtherIDs) R 
;;      (apply #'odbc-format-infix-wc Relation R (car OtherIDs) (cdr OtherIDs)))))


;;; ----------------------------------------------------------------
;;; format between
;;; Given an id and a pair of values or ids format a between clause
;;; that can be included as part of a select where clause.  This is
;;; equivelant to a pair of <= and >= clauses.
(defun odbc-format-between-clause (ID Val1 Val2)
  (format "~a BETWEEN ~a AND ~a" ID Val1 Val2))


;;; --------------------------------------------------------------------
;;; Produce a date string recoegnized by the odbc source.

(defun odbc-format-date (Month Day Year)
  "Compile a date string accounting for the month possibly being a string."
  (format Nil "~4,'0,D-~2,'0,D-~2,'0,D" Year
	  (if (numberp Month) Month 
	    (map-monthStr->MonthNum Month))
	  Day))

;;; --------------------------------------------------------------------
;;; Produce a time string recoegnized by an odbc source.

(defun odbc-format-time (Hour Min Sec)
  "Produce an encoded time string."
  (format Nil "~2,'0,D:~2,'0,D:~2,'0,D" Hour Min Sec))


;;; ---------------------------------------------------------------------
;;; Format a func
;;; Given a function name and one or more args format the results for odbc.
(defun odbc-format-func (Fname &rest args)
  (format Nil "~a(~a~{, ~a~})" Fname (car args) (cdr args)))


